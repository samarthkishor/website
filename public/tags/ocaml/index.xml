<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OCaml on Samarth&#39;s Blog</title>
    <link>https://samarthkishor.github.io/tags/ocaml/</link>
    <description>Recent content in OCaml on Samarth&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Samarth Kishor 2020</copyright>
    <lastBuildDate>Wed, 11 Mar 2020 22:49:00 -0400</lastBuildDate><atom:link href="https://samarthkishor.github.io/tags/ocaml/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Three Completely Different Approaches to the FizzBuzz Problem</title>
      <link>https://samarthkishor.github.io/posts/fizzbuzz_approaches/</link>
      <pubDate>Wed, 11 Mar 2020 22:49:00 -0400</pubDate>
      
      <guid>https://samarthkishor.github.io/posts/fizzbuzz_approaches/</guid>
      <description>Here&amp;rsquo;s a solution to the classic infamous FizzBuzz problem in Python:
for i in range(1, 31): if i % 15 == 0: print(&amp;#34;FizzBuzz&amp;#34;) elif i % 3 == 0: print(&amp;#34;Fizz&amp;#34;) elif i % 5 == 0: print(&amp;#34;Buzz&amp;#34;) else: print(i) 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz This program is really simple and is probably the most common approach.</description>
    </item>
    
    <item>
      <title>Interactive OCaml Development</title>
      <link>https://samarthkishor.github.io/posts/interactive_ocaml_development/</link>
      <pubDate>Sun, 08 Mar 2020 22:06:00 -0400</pubDate>
      
      <guid>https://samarthkishor.github.io/posts/interactive_ocaml_development/</guid>
      <description>Interactive development features are mostly found in dynamically-typed interpreted programming languages like Python or JavaScript. While OCaml is a statically-typed compiled language, it is still possible to program in an interactive style using a REPL. However, OCaml will never be quite as flexible and interactive as something like Lisp because of its greatest feature: the strong static type system.
Testing functions using the REPL One of the nicest features of OCaml is that is has both a byte-code compiler (ocamlc) and a native-code compiler (ocamlopt).</description>
    </item>
    
  </channel>
</rss>
