<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Samarth&#39;s Blog</title>
    <link>https://samarthkishor.github.io/posts/</link>
    <description>Recent content in Posts on Samarth&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Samarth Kishor 2020</copyright>
    <lastBuildDate>Thu, 13 Aug 2020 13:35:00 -0400</lastBuildDate>
    
	<atom:link href="https://samarthkishor.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Typed APIs in Python with dataclasses and NamedTuples</title>
      <link>https://samarthkishor.github.io/posts/typed_apis_in_python/</link>
      <pubDate>Thu, 13 Aug 2020 13:35:00 -0400</pubDate>
      
      <guid>https://samarthkishor.github.io/posts/typed_apis_in_python/</guid>
      <description>Why would Python programmers ever care about types? While Python doesn&amp;rsquo;t check any types statically (before running the program), it does perform extensive run-time type checking. Checking types at run-time without any implicit casts makes the language strongly-typed and dynamically-typed, as opposed to a language like C which is weakly-typed and statically-typed. This is an important distinction, but I won&amp;rsquo;t go over the differences between strong and weak typing in this post.</description>
    </item>
    
    <item>
      <title>Three Completely Different Approaches to the FizzBuzz Problem</title>
      <link>https://samarthkishor.github.io/posts/fizzbuzz_approaches/</link>
      <pubDate>Wed, 11 Mar 2020 22:49:00 -0400</pubDate>
      
      <guid>https://samarthkishor.github.io/posts/fizzbuzz_approaches/</guid>
      <description>Here&amp;rsquo;s a solution to the classic infamous FizzBuzz problem in Python:
for i in range(1, 31): if i % 15 == 0: print(&amp;#34;FizzBuzz&amp;#34;) elif i % 3 == 0: print(&amp;#34;Fizz&amp;#34;) elif i % 5 == 0: print(&amp;#34;Buzz&amp;#34;) else: print(i) 1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buzz Fizz 22 23 Fizz Buzz 26 Fizz 28 29 FizzBuzz This program is really simple and is probably the most common approach.</description>
    </item>
    
    <item>
      <title>Remote Linux Process Hacking through SSH</title>
      <link>https://samarthkishor.github.io/posts/remote_process_hacking/</link>
      <pubDate>Mon, 09 Mar 2020 22:10:00 -0400</pubDate>
      
      <guid>https://samarthkishor.github.io/posts/remote_process_hacking/</guid>
      <description>There&amp;rsquo;s this really cool process hacking series on YouTube by Keist Zenon. He uses the programming language Common Lisp to interact with processes on his Linux machine. I tried following the tutorial on my Mac, but macOS does not have the same ptrace commands and system call interfaces as Linux so this did not work out. However, I have VirtualBox set up on my Mac with a Debian VM which I use whenever I need Linux.</description>
    </item>
    
    <item>
      <title>Interactive OCaml Development</title>
      <link>https://samarthkishor.github.io/posts/interactive_ocaml_development/</link>
      <pubDate>Sun, 08 Mar 2020 22:06:00 -0400</pubDate>
      
      <guid>https://samarthkishor.github.io/posts/interactive_ocaml_development/</guid>
      <description>Interactive development features are mostly found in dynamically-typed interpreted programming languages like Python or JavaScript. While OCaml is a statically-typed compiled language, it is still possible to program in an interactive style using a REPL. However, OCaml will never be quite as flexible and interactive as something like Lisp because of its greatest feature: the strong static type system.
Testing functions using the REPL One of the nicest features of OCaml is that is has both a byte-code compiler (ocamlc) and a native-code compiler (ocamlopt).</description>
    </item>
    
  </channel>
</rss>