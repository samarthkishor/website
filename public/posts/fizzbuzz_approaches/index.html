<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"  lang="en-us">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Three Completely Different Approaches to the FizzBuzz Problem | Samarth&#39;s Blog</title>



<link href="https://samarthkishor.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Samarth&#39;s Blog">

<link rel="stylesheet" href="/css/style.css"><link rel='stylesheet' href='https://samarthkishor.github.io/css/styles.css'><link rel='stylesheet' href='https://samarthkishor.github.io/css/vertical-timeline.css'><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<link rel="canonical" href="https://samarthkishor.github.io/posts/fizzbuzz_approaches/">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">
</head>
<body>
<section class="section">
  <div class="container">
    <nav id="nav-main" class="nav">
      <div id="nav-name" class="nav-left">
        <a id="nav-anchor" class="nav-item" href="https://samarthkishor.github.io">
          <h1 id="nav-heading" class="title is-4">Samarth&#39;s Blog</h1>
        </a>
      </div>
      <div class="nav-right">
        <nav id="nav-items" class="nav-item level is-mobile"><a class="level-item" aria-label="github" href='https://github.com/samarthkishor'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="linkedin" href='https://linkedin.com/in/samarth-kishor'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path stroke-width="1.8" d="m5.839218,4.101561c0,1.211972 -0.974141,2.194011 -2.176459,2.194011s-2.176459,-0.982039 -2.176459,-2.194011c0,-1.211094 0.974141,-2.194011 2.176459,-2.194011s2.176459,0.982917 2.176459,2.194011zm0.017552,3.94922l-4.388022,0l0,14.04167l4.388022,0l0,-14.04167zm7.005038,0l-4.359939,0l0,14.04167l4.360816,0l0,-7.370999c0,-4.098413 5.291077,-4.433657 5.291077,0l0,7.370999l4.377491,0l0,-8.89101c0,-6.915523 -7.829986,-6.66365 -9.669445,-3.259423l0,-1.891237z"/>
    
  </svg></i>
            </span>
          </a><a class="level-item" aria-label="email" href='mailto:samarthkishor1@gmail.com'
            target='_blank' rel='noopener'>
            <span class="icon">
              <i class><svg viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
    
    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/>
    <polyline points="22,6 12,13 2,6"/>
    
  </svg></i>
            </span>
          </a></nav>
      </div>
    </nav>

    <nav class="nav">
      
      <div class="nav-left"><a class="nav-item" href="/about">
          <h2 class="title is-5">About</h2>
        </a><a class="nav-item" href="/posts">
          <h2 class="title is-5">Archive</h2>
        </a></div>
      

      
    </nav>

  </div>
  <script src="/js/navicon-shift.js"></script>
</section>
<section class="section">
  <div class="container">
    <div class="subtitle tags is-6 is-pulled-right">
      
      
<a class="subtitle is-6" href="/tags/programming/">#programming</a>



  
  | <a class="subtitle is-6" href="/tags/python/">#python</a>
  
  | <a class="subtitle is-6" href="/tags/ocaml/">#OCaml</a>
  
  | <a class="subtitle is-6" href="/tags/lisp/">#lisp</a>
  


      
    </div>
    <h2 class="subtitle is-6">March 11, 2020</h2>
    <h1 class="title">Three Completely Different Approaches to the FizzBuzz Problem</h1>
    
    <div class="content">
      <p>Here&rsquo;s a solution to the classic infamous FizzBuzz problem in Python:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">31</span>):
    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">15</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;FizzBuzz&#34;</span>)
    <span style="color:#66d9ef">elif</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Fizz&#34;</span>)
    <span style="color:#66d9ef">elif</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Buzz&#34;</span>)
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">print</span>(i)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
</code></pre></div><p>This program is really simple and is probably the most common approach. You just
need to understand how <code>if</code> statements work and you&rsquo;re good to go.</p>
<p>We can take this up a notch by using type-driven exhaustive pattern-matching so
that our programming language can actually tell us if we&rsquo;ve made a mistake in
our implementation. Here&rsquo;s version 2 of the FizzBuzz program using the OCaml
programming language:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Base</span>

<span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> 1 <span style="color:#66d9ef">to</span> 30 <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">match</span> Int.rem i 3<span style="color:#f92672">,</span> Int.rem i 5 <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> 0<span style="color:#f92672">,</span> 0 <span style="color:#f92672">-&gt;</span> Stdio.print_endline <span style="color:#e6db74">&#34;FizzBuzz&#34;</span>
    <span style="color:#f92672">|</span> 0<span style="color:#f92672">,</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> Stdio.print_endline <span style="color:#e6db74">&#34;Fizz&#34;</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">_,</span> 0 <span style="color:#f92672">-&gt;</span> Stdio.print_endline <span style="color:#e6db74">&#34;Buzz&#34;</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">_,</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> Stdio.printf <span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> i
  <span style="color:#66d9ef">done</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
</code></pre></div><p>Notice the <code>match</code> expression right after the <code>for</code> loop. OCaml has a really
powerful type system that can catch some tricky edge cases in our logic at
compile time. The function <code>Int.rem</code> is just like modulo in other languages (I&rsquo;m
using the <code>Base</code> alternate standard library for OCaml&mdash;the default language
comes with a <code>mod</code> operator). All the <code>match</code> expression in the code above is
doing is saying: &ldquo;If i mod 3 is 0 and i mod 5 is 0, then print FizzBuzz, else if
i mod 3 is 0 and i mod 5 is anything, then print Fizz, else if i mod 3 is
anything and i mod 5 is 0, then print Buzz, else print i if both are anything&rdquo;.</p>
<p>That looks an awful lot like a standard <code>if</code> statement to me. The real advantage
comes when you forget to include a case:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Base</span>

<span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">for</span> i <span style="color:#f92672">=</span> 1 <span style="color:#66d9ef">to</span> 30 <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">match</span> Int.rem i 3<span style="color:#f92672">,</span> Int.rem i 5 <span style="color:#66d9ef">with</span>
    <span style="color:#f92672">|</span> 0<span style="color:#f92672">,</span> 0 <span style="color:#f92672">-&gt;</span> Stdio.print_endline <span style="color:#e6db74">&#34;FizzBuzz&#34;</span>
    <span style="color:#f92672">|</span> 0<span style="color:#f92672">,</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> Stdio.print_endline <span style="color:#e6db74">&#34;Fizz&#34;</span>
    <span style="color:#f92672">|</span> <span style="color:#f92672">_,</span> 0 <span style="color:#f92672">-&gt;</span> Stdio.print_endline <span style="color:#e6db74">&#34;Buzz&#34;</span>
    <span style="color:#75715e">(* | _, _ -&gt; Stdio.printf &#34;%d\n&#34; i &lt;-- commented out *)</span>
  <span style="color:#66d9ef">done</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Characters 45-207:
  ....match Int.rem i 3, Int.rem i 5 with
      | 0, 0 -&gt; Stdio.print_endline &#34;FizzBuzz&#34;
      | 0, _ -&gt; Stdio.print_endline &#34;Fizz&#34;
      | _, 0 -&gt; Stdio.print_endline &#34;Buzz&#34;
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(1, 1)
Exception: Match_failure (&#34;//toplevel//&#34;, 50, 4).
Raised at file &#34;//toplevel//&#34;, line 53, characters 14-40
Called from file &#34;toplevel/toploop.ml&#34;, line 180, characters 17-56
</code></pre></div><p>This is really cool&mdash;OCaml&rsquo;s compiler knows when the <code>match</code> statement doesn&rsquo;t
cover all the possible cases and will even give you an example of a case that
wasn&rsquo;t met! Once we include that last case, the program will successfully
compile. Depending how you structure your pattern matching, the compiler will
sometimes even tell you if you&rsquo;ve used redundant or incorrect cases. It&rsquo;s a
killer feature and I wish more languages had it. Exhaustive pattern matching
like this is usually unique to strongly typed functional programming languages,
although Rust has also adopted this feature and I&rsquo;m sure others will follow.</p>
<p>Now for the third and wildest approach to solving the FizzBuzz problem&mdash;this
time with Clojure. Clojure is a Lisp dialect that emphasizes functional
programming and immutable data structures. This language also happens to have
great support for lazy sequences&mdash;a feature that this particular FizzBuzz
program uses heavily.</p>
<p>A lazy sequence is not evaluated immediately&mdash;instead, it delays its evaluation
until it is needed by another function.</p>
<p>To illustrate this, here&rsquo;s the documentation for the <code>cycle</code> function in
Clojure:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(doc cycle)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">-------------------------
clojure.core/cycle
([coll])
  Returns a lazy (infinite!) sequence of repetitions of the items in coll.
</code></pre></div><p>How do you use these so-called infinite sequences without using up all the
memory in your computer? The key to using lazy sequences is that these functions
are not evaluated until they are needed by another function. So running this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(cycle <span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;Fizz&#34;</span> <span style="color:#e6db74">&#34;Buzz&#34;</span>))
</code></pre></div><p>would just hang the Clojure session because it&rsquo;s waiting to be evaluated. Let&rsquo;s
fix that by taking some values from this infinite sequence.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(take <span style="color:#ae81ff">10</span> (cycle <span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">&#34;Fizz&#34;</span> <span style="color:#e6db74">&#34;Buzz&#34;</span>)))
</code></pre></div><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Fizz</td>
<td>Buzz</td>
<td>Fizz</td>
<td>Buzz</td>
<td>Fizz</td>
<td>Buzz</td>
<td>Fizz</td>
<td>Buzz</td>
<td>Fizz</td>
<td>Buzz</td>
</tr>
</tbody>
</table>
<p>Now we can write a completely different FizzBuzz implementation leveraging the
power of these lazy sequences. I modified the example from <a href="http://www.petecorey.com/blog/2018/07/09/golfing-for-fizzbuzz-in-clojure-and-elixir/">this blog post</a> so the
output would match my Python and OCaml programs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(<span style="color:#a6e22e">doseq</span>
    [x
     (<span style="color:#a6e22e">-&gt;&gt;</span>
      (map list
           (range <span style="color:#ae81ff">31</span>)
           (cycle [<span style="color:#e6db74">&#34;Fizz&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span>])
           (cycle [<span style="color:#e6db74">&#34;Buzz&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span>]))
      (<span style="color:#a6e22e">rest</span>)
      (map (<span style="color:#66d9ef">fn </span>[lst]
             (<span style="color:#66d9ef">let </span>[i (first lst)]
               (<span style="color:#66d9ef">if </span>(or (= <span style="color:#ae81ff">0</span> (<span style="color:#a6e22e">mod</span> i <span style="color:#ae81ff">3</span>)) (= <span style="color:#ae81ff">0</span> (<span style="color:#a6e22e">mod</span> i <span style="color:#ae81ff">5</span>)))
                 (apply str (concat (rest lst)))
                 (apply str (concat lst)))))))]
  (println x))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
</code></pre></div><p>The four lines of code below is the heart of the program. It uses the <code>range</code>
function to assign numbers to the first elements of the lists and then uses the
two <code>cycle</code> functions to assign either the empty string, Fizz, or Buzz to the
second and third elements of the list respectively. It&rsquo;s a really neat
declarative way of implementing FizzBuzz and my mind was completely blown when I
understood what the program really does.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-clojure" data-lang="clojure">(map list
     (range <span style="color:#ae81ff">31</span>)
     (cycle [<span style="color:#e6db74">&#34;Fizz&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span>])
     (cycle [<span style="color:#e6db74">&#34;Buzz&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#e6db74">&#34;&#34;</span>]))
</code></pre></div><table>
<thead>
<tr>
<th>0</th>
<th>Fizz</th>
<th>Buzz</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>Buzz</td>
</tr>
<tr>
<td>6</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td></td>
<td>Buzz</td>
</tr>
<tr>
<td>11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>Fizz</td>
<td>Buzz</td>
</tr>
<tr>
<td>16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td></td>
<td>Buzz</td>
</tr>
<tr>
<td>21</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>23</td>
<td></td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>25</td>
<td></td>
<td>Buzz</td>
</tr>
<tr>
<td>26</td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>Fizz</td>
<td></td>
</tr>
<tr>
<td>28</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>Fizz</td>
<td>Buzz</td>
</tr>
</tbody>
</table>
<p>I never knew FizzBuzz could be solved in so many different ways and it&rsquo;s a neat
little problem to illustrate the strengths and styles of different programming
languages: Python is great for writing legible imperative code that&rsquo;s simple yet
expressive. OCaml is great for writing safe strongly typed code with exhaustive
compiler checks when you need them. Clojure is great for writing highly dynamic
functional code which uses lots of abstractions that makes working with data
much easier.</p>

      
    </div>
    
  </div>
</section>



<section class="section">
  <div class="container has-text-centered">
    <p>&copy; Samarth Kishor 2020</p>
    
      <p>Powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/ribice/kiss">Kiss</a>.</p>
    
  </div>
</section>



<script data-goatcounter="https://samarth-personal-site.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>

</body>
</html>

