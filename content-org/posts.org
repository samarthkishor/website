#+TITLE: Samarth's Blog
#+HUGO_BASE_DIR: ../
#+OPTIONS:  ^:nil
#+HUGO_SECTION: posts/
#+HUGO_AUTO_SET_LASTMOD: t
#+DATE: 2020-06-29
#+STARTUP: logdone

* DONE Typed APIs in Python with dataclasses and NamedTuples :programming:python:
CLOSED: [2020-08-13 Thu 13:35]
:PROPERTIES:
:EXPORT_FILE_NAME: typed_apis_in_python
:END:

Why would Python programmers ever care about types? While Python doesn't check any types statically (before running the program), it does perform extensive run-time type checking. Checking types at run-time without any implicit casts makes the language strongly-typed and dynamically-typed, as opposed to a language like C which is weakly-typed and statically-typed. This is an important distinction, but I won't go over the differences between strong and weak typing in this post.

Newer versions of Python 3 have support for type annotations which gives the programmer some more information about types. Tools like =mypy= perform some basic static type checking. However, these static type-checkers are not all-powerful and sometimes it's useful to provide some extra type-safety dynamically at run-time.

** The API

Imagine you're writing a Python script that uses a stock market API. The API provides a GET method called =get_stocks= which returns some JSON data containing information about three very specific stocks you're interested in (this is important because we know exactly what data the API method will return and therefore can model it). This is a bit hand-wavy, but the actual API call doesn't matter---we only care about the JSON return value.

#+begin_src python :session stock-session :results output :exports both
import json
from pprint import pprint

def get_stocks() -> str:
    """
    API method returning some JSON data
    """

    return json.dumps(
        {
            "TSLA": {"price": "1000.00"},
            "AMZN": {"price": "3000.00"},
            "AAPL": {"price": "400.00"}
        }
    )


stock_data = get_stocks()
pprint(stock_data)
#+end_src

#+results:
: ('{"TSLA": {"price": "1000.00"}, "AMZN": {"price": "3000.00"}, "AAPL": '
:  '{"price": "400.00"}}')


We'd usually consume this API by serializing the JSON string to a Python =dict=.

#+begin_src python :session stock-session :results output :exports both
def get_tsla_price(stock_json_data: str) -> float:
    return float(json.loads(stock_json_data)["TSLA"]["price"])

print(get_tsla_price(stock_data))
#+end_src

#+results:
: 1000.0


This is alright, but remembering that the =price= field is a string can get tedious. Let's try and do better by defining the type of this JSON structure.

#+begin_src python :session stock-session :results output :exports both
from typing import Dict

def stocks_to_dict(stock_json_data: str) -> Dict[str, Dict[str, float]]:
    return json.loads(stock_json_data)

pprint(stocks_to_dict(stock_data))
#+end_src

#+results:
: {'AAPL': {'price': '400.00'},
:  'AMZN': {'price': '3000.00'},
:  'TSLA': {'price': '1000.00'}}


Now a static type-checker like =mypy= can assume that =stock_data["TSLA"]["price"]= is a =float=.

What if the API changes, and the =get_stocks= method also includes the company name and the percent change (I'm not a stock market expert so this might not be the correct term) in each stock JSON object?

#+begin_src python :session stock-session :results output :exports both
def get_stocks() -> str:
    """
    API method returning some JSON data
    """

    return json.dumps(
        {
            "TSLA": {
                "name": "Tesla, Inc.",
                "price": "1000.00",
                "percent_change": "+2.03%"
            },
            "AMZN": {
                "name": "Amazon.com, Inc.",
                "price": "3000.00",
                "percent_change": "-1.01%"
            },
            "AAPL": {
                "name": "Apple Inc.",
                "price": "400.00",
                "percent_change": "-1.51%"
            }
        }
    )

stock_data = get_stocks()

pprint(stock_data)
#+end_src

#+results:
: ('{"TSLA": {"name": "Tesla, Inc.", "price": "1000.00", "percent_change": '
:  '"+2.03%"}, "AMZN": {"name": "Amazon.com, Inc.", "price": "3000.00", '
:  '"percent_change": "-1.01%"}, "AAPL": {"name": "Apple Inc.", "price": '
:  '"400.00", "percent_change": "-1.51%"}}')


What does the type signature for the serialized =dict= even look like? We wouldn't want to keep the percent change as a string because that would be painful to work with.

This is my best guess but it's still not great.

#+begin_src python :session stock-session :results output :exports both
from typing import Dict, Union


def stocks_to_dict(stock_json_data: str) -> Dict[str, Dict[str, Union[float, str]]]:
    return json.loads(stock_json_data)


pprint(stocks_to_dict(stock_data))
#+end_src

#+results:
: {'AAPL': {'name': 'Apple Inc.', 'percent_change': '-1.51%', 'price': '400.00'},
:  'AMZN': {'name': 'Amazon.com, Inc.',
:           'percent_change': '-1.01%',
:           'price': '3000.00'},
:  'TSLA': {'name': 'Tesla, Inc.',
:           'percent_change': '+2.03%',
:           'price': '1000.00'}}


Most static typecheckers for Python will not complain that this =dict= still doesn't reflect the type of the function. Let's add some type conversions:

#+begin_src python :session stock-session :results output :exports both
from typing import Dict, Union


def stocks_to_dict(stock_json_data: str) -> Dict[str, Dict[str, Union[float, str]]]:
    stocks_dict = json.loads(stock_json_data)
    for symbol in stocks_dict.keys():
        stocks_dict[symbol]["price"] = float(stocks_dict[symbol]["price"])
    return stocks_dict


stocks_dict = stocks_to_dict(stock_data)
pprint(stocks_dict)
print(isinstance(stocks_dict["TSLA"]["price"], float))
#+end_src

#+results:
: {'AAPL': {'name': 'Apple Inc.', 'percent_change': '-1.51%', 'price': 400.0},
:  'AMZN': {'name': 'Amazon.com, Inc.',
:           'percent_change': '-1.01%',
:           'price': 3000.0},
:  'TSLA': {'name': 'Tesla, Inc.', 'percent_change': '+2.03%', 'price': 1000.0}}
: True

** Dynamically adding types

This works, but I'm lazy and don't want to write a specialized =x_to_dict= function for every single API method. I want something like a dynamically type-safe C =struct=---a data-structure that automatically serializes a =dict= with the correct type conversions. Another benefit of this =struct= is that it provides some basic documentation for what kinds of fields the API returns and their types. Dictionaries are still great and definitely have their place in Python programs, but in my opinion, an object called =Stocks= is a lot more descriptive and amenable to refactoring than =Dict[str, Dict[str, Union[float, str]]]=.

Here's an example of some of the functionality that I want:

#+begin_src python
stocks = Stocks(**json.loads(stock_data))
print(stocks.TSLA)  # -> nice representation of the object
print(stocks.TSLA.price)  # -> 1000.0
print(stocks.TSLA.percent_change)  # -> 0.0203
print(stocks.AMZN.percent_change)  # -> -0.0101
print(stocks.AAPL.name)  # -> "Apple Inc."
#+end_src

#+RESULTS:

Notice how the =price= and =percent_change= attributes will automatically get converted to =floats=.

Let's take a stab at implementing this with a regular class:

#+begin_src python :session stock-session :results output :exports both
def percent_to_float(percent: str) -> float:
    """
    Converts a percentage string to a float.

    e.g. percent_to_float("+1.01%") -> 0.0101
    e.g. percent_to_float("-22.22%") -> -0.2222
    """

    neg = -1 if percent[0] == "-" else 1
    return neg * float(percent[1:-1]) / 100


class Stocks:
   def __init__(self, *args, **kwargs):
       for symbol, info in kwargs.items():
           # e.g. sets self.TSLA to an empty object
           setattr(self, symbol, type("", (), {})())
           # e.g. sets self.TSLA.name to "Tesla, Inc."
           setattr(getattr(self, symbol), "name", info["name"])
           # e.g. sets self.TSLA.price to 1000.0
           setattr(getattr(self, symbol), "price", float(info["price"]))
           # # e.g. sets self.AMZN.percent_change to -0.0101
           setattr(getattr(self, symbol), "percent_change",
                   percent_to_float(info["percent_change"]))


stocks = Stocks(**json.loads(stock_data))
print(stocks.TSLA)  # -> nice representation of the object
print(stocks.TSLA.price)  # -> 1000.0
print(stocks.TSLA.percent_change)  # -> 0.0203
print(stocks.AMZN.percent_change)  # -> -0.0101
print(stocks.AAPL.name)  # -> "Apple Inc."
#+end_src

#+results:
: <__main__. object at 0x10ddcc5d0>
: 1000.0
: 0.0203
: -0.0101
: Apple Inc.


This works pretty well! We've used simple metaprogramming to dynamically create class attributes at run-time, all with the correct types! The only problem is that we'd have to add a =__repr__= method to each dynamically-created object to get a nice representation of =stocks.TSLA= when printed. Remember, I'm lazy so this is clearly too much work.

** Type-safety with dataclasses

Remember that this is Python and there's usually a simple answer to most problems in the standard library. Turns out that =NamedTuples= and =dataclasses= both do the trick.

#+begin_src python :session stock-session :results output :exports both
from dataclasses import dataclass


@dataclass
class StockInfo:
    name: str
    price: float
    percent_change: float

    def __post_init__(self):
        self.price = float(self.price)
        self.percent_change = percent_to_float(self.percent_change)


print(StockInfo(**json.loads(stock_data)["TSLA"]))
#+end_src

#+results:
: StockInfo(name='Tesla, Inc.', price=1000.0, percent_change=0.0203)


That was easy! Now we can simplify the =Stock= class to use these =StockInfo= objects.

#+begin_src python :session stock-session :results output :exports both
class Stocks:
   def __init__(self, *args, **kwargs):
       for symbol, info in kwargs.items():
           # e.g. sets self.TSLA to StockInfo object
           setattr(self, symbol, StockInfo(**info))


stocks = Stocks(**json.loads(stock_data))
print(stocks.TSLA)  # -> nice representation of the object
print(stocks.TSLA.price)  # -> 1000.0
print(stocks.TSLA.percent_change)  # -> 0.0203
print(stocks.AMZN.percent_change)  # -> -0.0101
print(stocks.AAPL.name)  # -> "Apple Inc."
#+end_src

#+results:
: StockInfo(name='Tesla, Inc.', price=1000.0, percent_change=0.0203)
: 1000.0
: 0.0203
: -0.0101
: Apple Inc.


As an added bonus, printing out =stocks.TSLA= gives us a nice representation of the =StockInfo= object, where before it would print out the raw Python object which isn't that helpful (of course, it's easy enough to add a =__repr__= method but that's too much work).

What happens if we try and update the stock?

#+begin_src python :session stock-session :results output :exports both
stocks.TSLA.name = "SpaceX, Inc."
print(stocks.TSLA)
#+end_src

#+results:
: StockInfo(name='SpaceX, Inc.', price=1000.0, percent_change=0.0203)


This isn't good. I want these objects to be immutable which will prevent a whole class of potential errors.

Turns out that =dataclasses= can be immutable with a quick modification to the decorator. That should do the trick?

#+begin_src python :session stock-session :results output :exports both
@dataclass(frozen=True)
class StockInfo:
    name: str
    price: float
    percent_change: float

    def __post_init__(self):
        self.price = float(self.price)
        self.percent_change = percent_to_float(self.percent_change)


print(StockInfo(**json.loads(stock_data)["TSLA"]))
#+end_src

#+results:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/var/folders/9k/rrglbkg540qc7_jb7g6d9l8r0000gn/T/babel-Jeqvjt/python-DECY0g", line 12, in <module>
:     print(StockInfo(**json.loads(stock_data)["TSLA"]))
:   File "<string>", line 6, in __init__
:   File "/var/folders/9k/rrglbkg540qc7_jb7g6d9l8r0000gn/T/babel-Jeqvjt/python-DECY0g", line 8, in __post_init__
:     self.price = float(self.price)
:   File "<string>", line 4, in __setattr__
: dataclasses.FrozenInstanceError: cannot assign to field 'price'


Looks like the frozen property gets enforced immediately after the =dataclass= gets initialized, so there's no way to change the class instance variables after they're set.

There's a workaround where you can use =super().__setattr__= to bypass the restrictions on calling =setattr= directly because of the =frozen= property. [[https://stackoverflow.com/a/54119384/7432268][(relevant StackOverflow post)]]

#+begin_src python :session stock-session :results output :exports both
@dataclass(frozen=True)
class StockInfo:
    name: str
    price: float
    percent_change: float

    def __post_init__(self):
        super().__setattr__("price", float(self.price))
        super().__setattr__("percent_change", percent_to_float(self.percent_change))


stocks = Stocks(**json.loads(stock_data))
print(stocks.TSLA)

stocks.TSLA.name = "SpaceX, Inc."  # raises an error
#+end_src

#+results:
: StockInfo(name='Tesla, Inc.', price=1000.0, percent_change=0.0203)
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/var/folders/9k/rrglbkg540qc7_jb7g6d9l8r0000gn/T/babel-Jeqvjt/python-wfC3n6", line 15, in <module>
:     stocks.TSLA.name = "SpaceX, Inc."  # raises an error
:   File "<string>", line 4, in __setattr__
: dataclasses.FrozenInstanceError: cannot assign to field 'name'

#+begin_src python :session stock-session :exports none
DCStockInfo = StockInfo
#+end_src

#+RESULTS:
: None

Looks like this is working properly.

** Type-safety with NamedTuples

If you don't want to use =dataclasses=, a =NamedTuple= works just as well. =NamedTuples= are immutable by default. We want to do the type conversions before the object is actually initialized using =__new__= because once the =NamedTuple= is created, it's immutable.

#+begin_src python :session stock-session :results output :exports both
from typing import NamedTuple


class StockInfo(NamedTuple):
    name: str
    price: float
    percent_change: float

    def __new__(cls, *args, **kwargs):
        kwargs["price"] = float(kwargs["price"])
        kwargs["percent_change"] = percent_to_float(kwargs["percent_change"])
        return super().__new__(cls, *args, **kwargs)


print(StockInfo(**json.loads(stock_data)["TSLA"]))
#+end_src

#+results:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/var/folders/9k/rrglbkg540qc7_jb7g6d9l8r0000gn/T/babel-Jeqvjt/python-Gv1AH2", line 3, in <module>
:     class StockInfo(NamedTuple):
:   File "/usr/local/Cellar/python/3.7.7/Frameworks/Python.framework/Versions/3.7/lib/python3.7/typing.py", line 1386, in __new__
:     raise AttributeError("Cannot overwrite NamedTuple attribute " + key)
: AttributeError: Cannot overwrite NamedTuple attribute __new__


Turns out we can't modify the =__new__= method directly to convert the types, but it's possible to hack around this via sub-classing.

#+begin_src python :session stock-session :results output :exports both
from typing import NamedTuple


class _BaseStockInfo(NamedTuple):
    name: str
    price: float
    percent_change: float


class StockInfo(_BaseStockInfo):
    def __new__(cls, *args, **kwargs):
        kwargs["price"] = float(kwargs["price"])
        kwargs["percent_change"] = percent_to_float(kwargs["percent_change"])
        return super().__new__(cls, *args, **kwargs)


stocks = Stocks(**json.loads(stock_data))
print(stocks.TSLA)
stocks.TSLA.name = "SpaceX, Inc."  # raises an error
#+end_src

#+results:
: StockInfo(name='Tesla, Inc.', price=1000.0, percent_change=0.0203)
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/var/folders/9k/rrglbkg540qc7_jb7g6d9l8r0000gn/T/babel-Jeqvjt/python-CHqjcX", line 18, in <module>
:     stocks.TSLA.name = "SpaceX, Inc."  # raises an error
: AttributeError: can't set attribute

Looks like it's working properly.

Let's just do a quick check to make sure everything works:

#+begin_src python :session stock-session :results output :exports both
stocks = Stocks(**json.loads(stock_data))
print(stocks.TSLA.price)  # -> 1000.0
print(stocks.TSLA.percent_change)  # -> 0.0203
print(stocks.AMZN.percent_change)  # -> -0.0101
print(stocks.AAPL.name)  # -> "Apple Inc."
#+end_src

#+results:
: 1000.0
: 0.0203
: -0.0101
: Apple Inc.

#+begin_src python :session stock-session :exports none
NTStockInfo = StockInfo
#+end_src

#+RESULTS:
: None

Now we have a nice strongly-typed wrapper object for our previously stringly-typed JSON data!

** Dataclass vs NamedTuple

*** Unpacking

What if we want to unpack the =StockInfo= object for multiple-assignment?

This is easy with =NamedTuples= since they work just like regular tuples.

#+begin_src python :session stock-session :results output :exports both
tsla = NTStockInfo(**json.loads(stock_data)["TSLA"])
print("TSLA values: ", *tsla, sep=" | ")
name, _, percent_change = tsla
print(f"percent change for {name} stock is {percent_change}")
#+END_SRC

#+RESULTS:
: TSLA values:  | Tesla, Inc. | 1000.0 | 0.0203
: percent change for Tesla, Inc. stock is 0.0203

The same can't be said for a =dataclass=.

#+begin_src python :session stock-session :results output :exports both
tsla = DCStockInfo(**json.loads(stock_data)["TSLA"])
name, _, percent_change = tsla
print(f"percent change for {name} stock is {percent_change}")
#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/var/folders/9k/rrglbkg540qc7_jb7g6d9l8r0000gn/T/babel-Jeqvjt/python-dlN3nO", line 2, in <module>
:     name, _, percent_change = tsla
: TypeError: cannot unpack non-iterable StockInfo object

We can work around this by using the =dataclasses.astuple= function, but it's not as intuitive.

#+begin_src python :session stock-session :results output :exports both
import dataclasses

tsla = DCStockInfo(**json.loads(stock_data)["TSLA"])
print("TSLA values: ", *dataclasses.astuple(tsla), sep=" | ")
name, _, percent_change = dataclasses.astuple(tsla)
print(f"percent change for {name} stock is {percent_change}")
#+END_SRC

#+RESULTS:
: TSLA values:  | Tesla, Inc. | 1000.0 | 0.0203
: percent change for Tesla, Inc. stock is 0.0203

*** Serializing to JSON

Since we're dealing with APIs, it's useful to quickly be able to serialize an object to JSON with the correct types.

#+begin_src python :session stock-session :results output :exports both
tsla = NTStockInfo(**json.loads(stock_data)["TSLA"])

# the _asdict() method converts a NamedTuple to a mapping type
pprint(json.dumps(tsla._asdict()))
#+END_SRC

#+RESULTS:
: '{"name": "Tesla, Inc.", "price": 1000.0, "percent_change": 0.0203}'

#+begin_src python :session stock-session :results output :exports both
import dataclasses

tsla = DCStockInfo(**json.loads(stock_data)["TSLA"])
pprint(json.dumps(dataclasses.asdict(tsla)))
#+END_SRC

#+RESULTS:
: '{"name": "Tesla, Inc.", "price": 1000.0, "percent_change": 0.0203}'

Both approaches work equally well in this case.

*** Documentation

The =dataclass= implementation is, in my opinion, simpler to implement and has nicer built-in documentation via =help(StockInfo)=.

#+BEGIN_SRC
Help on class StockInfo in module __main__:

class StockInfo(builtins.object)
 |  StockInfo(name: str, price: float, percent_change: float) -> None
#+END_SRC

Since our =NamedTuple= implementation is a sub-class, we have to scroll down a bit to find the attributes of the class in the =help= output, and the type annotations are hidden away as an =OrderedDict= in the =_fields= attribute.

#+BEGIN_SRC
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from _BaseStockInfo:
 |
 |  name
 |      Alias for field number 0
 |
 |  price
 |      Alias for field number 1
 |
 |  percent_change
 |      Alias for field number 2
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from _BaseStockInfo:
 |
 |  __annotations__ = OrderedDict([('name', <class 'str'>), ('price', ... ...
 |
 |  _field_defaults = {}
 |
 |  _field_types = OrderedDict([('name', <class 'str'>),
#+END_SRC



* DONE Three Completely Different Approaches to the FizzBuzz Problem :programming:python:OCaml:lisp:
CLOSED: [2020-03-11 Mon 22:49]
:PROPERTIES:
:EXPORT_FILE_NAME: fizzbuzz_approaches
:END:

Here's a solution to the classic infamous FizzBuzz problem in Python:

#+BEGIN_SRC python :results output :exports both
for i in range(1, 31):
    if i % 15 == 0:
        print("FizzBuzz")
    elif i % 3 == 0:
        print("Fizz")
    elif i % 5 == 0:
        print("Buzz")
    else:
        print(i)
#+END_SRC

#+RESULTS:
#+begin_example
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
#+end_example

This program is really simple and is probably the most common approach. You just
need to understand how =if= statements work and you're good to go.

We can take this up a notch by using type-driven exhaustive pattern-matching so
that our programming language can actually tell us if we've made a mistake in
our implementation. Here's version 2 of the FizzBuzz program using the OCaml
programming language:

#+BEGIN_SRC ocaml :exports both
open Base

let () =
  for i = 1 to 30 do
    match Int.rem i 3, Int.rem i 5 with
    | 0, 0 -> Stdio.print_endline "FizzBuzz"
    | 0, _ -> Stdio.print_endline "Fizz"
    | _, 0 -> Stdio.print_endline "Buzz"
    | _, _ -> Stdio.printf "%d\n" i
  done
#+END_SRC

#+RESULTS:
#+begin_example
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
#+end_example

Notice the =match= expression right after the =for= loop. OCaml has a really
powerful type system that can catch some tricky edge cases in our logic at
compile time. The function =Int.rem= is just like modulo in other languages (I'm
using the =Base= alternate standard library for OCaml---the default language
comes with a =mod= operator). All the =match= expression in the code above is
doing is saying: "If i mod 3 is 0 and i mod 5 is 0, then print FizzBuzz, else if
i mod 3 is 0 and i mod 5 is anything, then print Fizz, else if i mod 3 is
anything and i mod 5 is 0, then print Buzz, else print i if both are anything".

That looks an awful lot like a standard =if= statement to me. The real advantage
comes when you forget to include a case:

#+BEGIN_SRC ocaml :exports both
open Base

let () =
  for i = 1 to 30 do
    match Int.rem i 3, Int.rem i 5 with
    | 0, 0 -> Stdio.print_endline "FizzBuzz"
    | 0, _ -> Stdio.print_endline "Fizz"
    | _, 0 -> Stdio.print_endline "Buzz"
    (* | _, _ -> Stdio.printf "%d\n" i <-- commented out *)
  done
#+END_SRC

#+RESULTS:
#+begin_example
Characters 45-207:
  ....match Int.rem i 3, Int.rem i 5 with
      | 0, 0 -> Stdio.print_endline "FizzBuzz"
      | 0, _ -> Stdio.print_endline "Fizz"
      | _, 0 -> Stdio.print_endline "Buzz"
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(1, 1)
Exception: Match_failure ("//toplevel//", 228, 4).
Raised at file "//toplevel//", line 231, characters 14-40
Called from file "toplevel/toploop.ml", line 180, characters 17-56
#+end_example

This is really cool---OCaml's compiler knows when the =match= statement doesn't
cover all the possible cases and will even give you an example of a case that
wasn't met! Once we include that last case, the program will successfully
compile. Depending how you structure your pattern matching, the compiler will
sometimes even tell you if you've used redundant or incorrect cases. It's a
killer feature and I wish more languages had it. Exhaustive pattern matching
like this is usually unique to strongly typed functional programming languages,
although Rust has also adopted this feature and I'm sure others will follow.

Now for the third and wildest approach to solving the FizzBuzz problem---this
time with Clojure. Clojure is a Lisp dialect that emphasizes functional
programming and immutable data structures. This language also happens to have
great support for lazy sequences---a feature that this particular FizzBuzz
program uses heavily.

A lazy sequence is not evaluated immediately---instead, it delays its evaluation
until it is needed by another function.

To illustrate this, here's the documentation for the =cycle= function in
Clojure:

#+BEGIN_SRC clojure :results output :exports both :eval never-export
(doc cycle)
#+END_SRC

#+RESULTS:
: -------------------------
: clojure.core/cycle
: ([coll])
:   Returns a lazy (infinite!) sequence of repetitions of the items in coll.

How do you use these so-called infinite sequences without using up all the
memory in your computer? The key to using lazy sequences is that these functions
are not evaluated until they are needed by another function. So running this:

#+BEGIN_SRC clojure
(cycle '("Fizz" "Buzz"))
#+END_SRC

would just hang the Clojure session because it's waiting to be evaluated. Let's
fix that by taking some values from this infinite sequence.

#+BEGIN_SRC clojure :exports both :eval never-export
(take 10 (cycle '("Fizz" "Buzz")))
#+END_SRC

#+RESULTS:
| Fizz | Buzz | Fizz | Buzz | Fizz | Buzz | Fizz | Buzz | Fizz | Buzz |

Now we can write a completely different FizzBuzz implementation leveraging the
power of these lazy sequences. I modified the example from [[http://www.petecorey.com/blog/2018/07/09/golfing-for-fizzbuzz-in-clojure-and-elixir/][this blog post]] so the
output would match my Python and OCaml programs.

#+BEGIN_SRC clojure :results output :exports both :eval never-export
(doseq
    [x
     (->>
      (map list
           (range 31)
           (cycle ["Fizz" "" ""])
           (cycle ["Buzz" "" "" "" ""]))
      (rest)
      (map (fn [lst]
             (let [i (first lst)]
               (if (or (= 0 (mod i 3)) (= 0 (mod i 5)))
                 (apply str (concat (rest lst)))
                 (apply str (concat lst)))))))]
  (println x))
#+END_SRC

#+RESULTS:
#+begin_example
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
#+end_example

The four lines of code below is the heart of the program. It uses the =range=
function to assign numbers to the first elements of the lists and then uses the
two =cycle= functions to assign either the empty string, Fizz, or Buzz to the
second and third elements of the list respectively. It's a really neat
declarative way of implementing FizzBuzz and my mind was completely blown when I
understood what the program really does.

#+BEGIN_SRC clojure :exports both :eval never-export
(map list
     (range 31)
     (cycle ["Fizz" "" ""])
     (cycle ["Buzz" "" "" "" ""]))
#+END_SRC

#+RESULTS:
|  0 | Fizz | Buzz |
|  1 |      |      |
|  2 |      |      |
|  3 | Fizz |      |
|  4 |      |      |
|  5 |      | Buzz |
|  6 | Fizz |      |
|  7 |      |      |
|  8 |      |      |
|  9 | Fizz |      |
| 10 |      | Buzz |
| 11 |      |      |
| 12 | Fizz |      |
| 13 |      |      |
| 14 |      |      |
| 15 | Fizz | Buzz |
| 16 |      |      |
| 17 |      |      |
| 18 | Fizz |      |
| 19 |      |      |
| 20 |      | Buzz |
| 21 | Fizz |      |
| 22 |      |      |
| 23 |      |      |
| 24 | Fizz |      |
| 25 |      | Buzz |
| 26 |      |      |
| 27 | Fizz |      |
| 28 |      |      |
| 29 |      |      |
| 30 | Fizz | Buzz |

I never knew FizzBuzz could be solved in so many different ways and it's a neat
little problem to illustrate the strengths and styles of different programming
languages: Python is great for writing legible imperative code that's simple yet
expressive. OCaml is great for writing safe strongly typed code with exhaustive
compiler checks when you need them. Clojure is great for writing highly dynamic
functional code which uses lots of abstractions that makes working with data
much easier.


* DONE Remote Linux Process Hacking through SSH :programming:lisp:linux:
CLOSED: [2020-03-09 Mon 22:10]
:PROPERTIES:
:EXPORT_FILE_NAME: remote_process_hacking
:END:

There's this really cool [[https://www.youtube.com/playlist?list=PLBgJcoaU2hl-JnoVOzjYB5qk_PfYjPm-I][process hacking series]] on YouTube by Keist Zenon. He
uses the programming language Common Lisp to interact with processes on his
Linux machine. I tried following the tutorial on my Mac, but macOS does not have
the same =ptrace= commands and system call interfaces as Linux so this did not
work out. However, I have VirtualBox set up on my Mac with a Debian VM which I
use whenever I need Linux.

Here's the idea: is it possible to hack processes on my Linux VM from Emacs on
my Mac? I found out that it's not only possible, but it's actually surprisingly
easy.

** Configuring the Virtual Machine
# :PROPERTIES:
# :HEADER-ARGS:sh: :dir /ssh:debian-box:/home/samarth/cl-ptrace
# :END:

First you'll need to set up a Bridged Adapter on your VirtualBox VM to allow
your host machine to connect to it via SSH. [[https://www.youtube.com/watch?v=ErzhbUusgdI][This YouTube tutorial]] was pretty
helpful. You'll just have to change how you enable the SSH service on your Linux
VM---I'm on Debian so I had to run the command

#+BEGIN_SRC sh :exports both :eval never-export
systemctl status ssh | cat | grep active
#+END_SRC

#+RESULTS:
: Active: active (running) since Fri 2020-03-13 18:24:14 EDT; 33s ago

to see if SSH was enabled.

To attach and manipulate this process, we need to use the =ptrace= function. You
can see the documentation for it with the command =man 2 ptrace= (2 stands for
the second section of the manual, since we want the C system call function for
=ptrace= instead of the general UNIX command). We could use C for process
hacking, but it's a lot nicer to use an interactive language like Lisp. Plus,
it's possible to interact with a remote Lisp REPL from your host machine's local
Emacs instance through SSH. Common Lisp is pretty amazing---I don't know if many
other programming languages have these features.

Clone [[https://github.com/k-stz/cl-ptrace][Keist's GitHub repo]] to your VM to get his Common Lisp library for process
hacking with =ptrace=. The code here is essentially the same as the tutorial,
except you might have to remove the line that says

#+BEGIN_SRC common-lisp
(:file "cl-ptrace/async-functions")
#+END_SRC

since that file doesn't exist in the repo for some reason. Install your Common
Lisp implementation of choice (I use =sbcl= since it's well-supported on most
platforms) and follow the instructions on the [[https://www.quicklisp.org/beta/][Quicklisp website]] to install
Quicklisp. Quicklisp is the unofficial package manager for Common Lisp.

Once you've successfully installed Quicklisp, you need to set up a Lisp REPL on
the remote VM so it can talk to your local Emacs editor. Quit out of your =sbcl=
repl and run it as root. We need Lisp to run as root since the =ptrace= system
calls need root access.

#+BEGIN_SRC sh
sudo sbcl
#+END_SRC

In his tutorial, Kaiste avoided this problem by running Emacs as root since he
was hacking processes from the same machine. However, we don't want to do this
since running Emacs as root can be dangerous, plus we are trying to hack
processes on our /remote/ machine from our /local (host)/ Emacs editor, so
running Emacs locally as root wouldn't really be useful.

Use Quicklisp to load/install =ASDF= and =slynk=, and then create a =slynk=
server on port 4006. You can use the default port 4005 if it's open.

#+BEGIN_SRC common-lisp
(ql:quickload :asdf)
(ql:quickload :slynk)
(slynk:create-server :port 4006)
#+END_SRC

If you get stuck, follow the instructions in [[https://joaotavora.github.io/sly/#Setting-up-the-Lisp-image][the SLY manual]], but I think
Quicklisp makes this process a bit easier.

Now fire up a new terminal and get your VM's ip address. On Debian, the command
is

#+BEGIN_SRC sh :eval never-export
hostname -I
#+END_SRC

#+RESULTS:
: 192.168.1.4

After that, SSH into your VM from your /host/ machine to create an SSH tunnel
that we'll take advantage of later.

#+BEGIN_SRC sh
ssh -L4006:localhost:4006 <username>@<ip-address>
#+END_SRC

Change =4006= to the port that =slynk= is using to run your Lisp server, and
change the =<username>= and =<ip-address>= fields. Remember to run this command
from your host machine, not the VM.

Once your SSH tunnel is set up, follow the instructions in section 8.1.3 of the
SLY manual (linked above) to configure Emacs to translate filenames between the
remote and host machines. Make sure you have TRAMP installed and working in
Emacs. Now you can connect to your VM from your host machine's Emacs using
TRAMP. =C-x C-f /ssh:<username>@<ip-address>= should do the trick. Now you can
navigate to the =cl-ptrace= repo.

The setup is pretty much over: now we can start hacking. Compile the =spam.c=
file in the =cl-ptrace= repo on your VM into the executable =spam= and run it.

#+BEGIN_SRC sh
gcc spam.c -o spam
./spam
#+END_SRC

We want to get the process id (=pid=) of this =spam= program so we can interact
with it. To do this, run the command

#+NAME: spam-pid
#+BEGIN_SRC sh :exports both :eval never-export
ps -a | grep spam | awk '{ print $1 }'
#+END_SRC

#+RESULTS: spam-pid
: 1543

We can then display information about the process with =top=. You can get a
nicer output by using the =htop= program.

#+BEGIN_SRC sh :var PID=spam-pid
top -p $PID
#+END_SRC

We can even limit the output of =top= to just get the CPU usage. The =sed=
commands are just for making the output nicer.

#+BEGIN_SRC sh :var PID=spam-pid :exports both :eval never-export
top -p $PID -n 2 -b | grep Cpu | sed 's/\:/\: /' | sed 's/us,.*/ /'
#+END_SRC

#+RESULTS:
| %Cpu(s): |  53.6 |
| %Cpu(s): | 100.0 |

Notice that the =spam= program is taking up over 90% of the CPU since it's an
infinite =while= loop in a single-threaded process.

** Hacking in Emacs

Next, switch back to Emacs (on the host machine) and make sure you're in the
remote =cl-ptrace= repo via TRAMP. We want to connect to the remote Lisp server
from Emacs, so run the command =M-x sly-connect=, keep the default host as
=localhost=, and change the port to the =slynk= server port.

Now you have a local Lisp REPL that is connected to your VM via the SSH tunnel
we created earlier. Load the file =cl-ptrace.asd= with the command =M-x
sly-load-file=. The file is on the remote VM, but this isn't a problem because
TRAMP should be configured to handle the remote filenames (we did this earlier).
This should load the file into the =sly= REPL. Then run =(asdf:load-system
"cl-ptrace")= to load the =cl-ptrace= library into the REPL, and run
=(in-package :cl-ptrace)= to start using the library.

Make sure that you're root by running the function =(am-i-root?)=. It should
return =T=. Now you've successfully created a mechanism to hack remote processes
from your local machine using Common Lisp and Emacs. Go ahead and follow along
with the rest of Kaiste's videos---they're amazing.

* Interactive OCaml Development :OCaml:programming:
CLOSED: [2020-03-08 Sun 22:06]
:PROPERTIES:
:EXPORT_FILE_NAME: interactive_ocaml_development
:END:

Interactive development features are mostly found in dynamically-typed
interpreted programming languages like Python or JavaScript. While OCaml is a
statically-typed compiled language, it is still possible to program in an
interactive style using a REPL. However, OCaml will never be quite as flexible
and interactive as something like Lisp because of its greatest feature: the
strong static type system.

** Testing functions using the REPL

One of the nicest features of OCaml is that is has both a byte-code compiler
(=ocamlc=) and a native-code compiler (=ocamlopt=). This means that you can
develop programs in an interactive, [[http://www.paulgraham.com/progbot.html][bottom-up]] style using the REPL. Bottom-up
development is a technique most-often leveraged by Lisp programmers in which you
can write a single function, compile it and send it to the REPL, and then test
that function interactively in the REPL. OCaml's fast bytecode compiler makes it
possible to use this technique that is usually unique to Lisps and interpreted
languages.

*** Sending code to the REPL in Emacs
I'll describe the process for interactive development using Emacs which is my
text editor of choice. Similar techniques should exist for other editors such as
VS Code or Vim.

OCaml's REPL is called =utop= and it has a lot of nice features that make it
well-suited for interactive development. If you're using Emacs, you can send
your OCaml code to =utop= to be evaluated. Here's an example of using =utop= to
test a single function.

#+BEGIN_SRC ocaml
open Base

let sum_list list = List.fold ~f:( + ) ~init:0 list
#+END_SRC

To send this code to =utop=, highlight it and press =C-x C-r= (or =M-x
utop-eval-region RET=). You can even send an entire buffer to =utop= by pressing
=C-c C-b= via the function =utop-eval-buffer=. If you use the =dune= build
system and configure Emacs appropriately (instructions on how to do this are in
the [[https://github.com/ocaml-community/utop#main-setup][utop documentation]]), a dialog will pop up saying: "utop command line: opam
config exec -- dune utop . -- -emacs". Press =RET= to evaluate the code.

You might have seen a message saying "Error: unbound module Base". This code
uses [[https://opensource.janestreet.com/base/][Jane Street's Base alternative standard library]] which makes things a bit
more complicated, since =utop= does not know about Base by default.

To solve this, create a new file in the same directory called =.ocamlinit=.
=utop= reads this file before starting and executes the commands specified. You
just need to include a single line to load the Base library into =utop=:

#+BEGIN_SRC ocaml
#require "base";;
#+END_SRC

Now try the previous steps again to load the =sum_list= function into =utop=. If
this still doesn't work, make sure your =opam= environment is set up correctly
by running the command =opam switch= in a terminal and following the
instructions.

Once everything is working, go ahead and test the function in the REPL by
running =sum_list [1; 2; 3];;= (the double semicolons at the end of the line are
important because =utop= uses them to mark the end of an expression). If you
want to make changes to the function, simply switch back to the OCaml buffer,
edit the code, and send it back to =utop=.

*** Working with multiple files in the REPL

The technique I described above works great within a single file, but things get
complicated once you send code from multiple files to the same =utop= instance.
For example, say you made the =sum_list= function within a file called
=test.ml= and sent that code to =utop=. Now you want to use =Test.sum_list=
within another file, so you create a new file called =use_test.ml= which
implements a new function:

#+BEGIN_SRC ocaml
let double_sum_list list = (Test.sum_list list) * 2
#+END_SRC

Now when you go to send this new function to =utop=, you run into an error:
"Error: Unbound module Test".

Here's the full sample =utop= session:

#+BEGIN_SRC
utop[0]> open Base

let sum_list list = List.fold ~f:( + ) ~init:0 list
;;
val sum_list : int list -> int = <fun>
utop[1]> sum_list [1; 2; 3];;
- : int = 6
utop[2]> let double_sum_list list = (Test.sum_list list) * 2
;;

Error: Unbound module Test
#+END_SRC

Since OCaml isn't really made to be an interactive programming language, there
isn't a clean solution for this problem as far as I'm aware. However, you can
hack around this using the same =.ocamlinit= file that I mentioned before.

Kill =utop= and modify the =.ocamlinit= file to look like this:

#+BEGIN_SRC ocaml
#require "base";;
#mod_use "test.ml";;
#+END_SRC

The =#mod_use= function tells =utop= to import the given file into the REPL as a
module. This is important because it lets us call =sum_list= as =Test.sum_list=.
=#mod_use= essentially wraps up the functions from the file into a module and
sends that module to be evaluated in the REPL, which is basically how the OCaml
compiler treats OCaml files. We don't want to change our development style to
work with the REPL since =utop= is configurable enough.

There is one caveat with this approach: you have to edit =.ocamlinit= and
restart =utop= whenever you create a new file. If you switch files (say you were
sending code from =use_test.ml= to the REPL but now want to work with
=test.ml=), you have to restart =utop= each time to ensure that it has the most
up-to-date version of all your files/modules. This is a bit of a pain and I'm
not sure if there's a solution to this problem given OCaml's static nature.

** Pretty-printing

A major part of interactive development is seeing the results of functions in
the REPL. Since OCaml has a strong type system without dynamic dispatch, you can
only print strings---this means that you have to write functions to convert your
user-defined types (which are everywhere in idiomatic OCaml code) to strings
each time you want to print them. This is a pain, but luckily there's an elegant
solution: [[https://github.com/ocaml-ppx/ppx_deriving#plugin-show][ppx]].

=ppx= is a syntax extension to OCaml which acts as a macro that automatically
generates code to pretty-print a custom type (=ppx_deriving.show=), generate
equality functions (=ppx_deriving.eq=), etc.

To pretty-print custom types annotated with =[@@deriving show]= in =utop=, you'll need to
once again modify the =.ocamlinit= file and add the following line:

#+BEGIN_SRC ocaml
#install_printer Module.pp;;
#+END_SRC

where =Module= is the name of the module which has the corresponding =pp=
function. Here's an example of one such module that pretty-prints a custom
hash-table with the =Depths= module, where =type t=... =[@@deriving show]= refers
to the =Resolver.t= type:

#+BEGIN_SRC ocaml
module Depths = struct
  type t = (string, int) Hashtbl.t

  let pp ppf values =
    Caml.Format.open_hovbox 1;
    Caml.Format.print_cut ();
    if Hashtbl.length values = 0
    then Caml.Format.fprintf ppf "@[<hov 2>{}@]"
    else (
      Caml.Format.fprintf ppf "@[<hov 1>{@ @]";
      Hashtbl.iteri values ~f:(fun ~key ~data ->
          Caml.Format.fprintf ppf "@[<hov 2>%s: %d,@ @]" key data);
      Caml.Format.fprintf ppf "@[<hov 1>}@]");
    Caml.Format.close_box ()
  ;;
end

type t =
  { statements : Parser.statement list
  ; scopes : Scopes.t
  ; depths : Depths.t
  ; parsed_statements : Parser.statement list
  }
[@@deriving show]
#+END_SRC

Here are the corresponding lines in =.ocamlinit= which tell =utop= which types
to pretty-print (the above code is from a file called =resolver.ml=):

#+BEGIN_SRC ocaml
#install_printer Resolver.pp;;
#install_printer Resolver.Depths.pp;;
#+END_SRC

Now =utop= knows to call the respective =pp= function whenever it needs to print
type information for the corresponding module. I needed to write the custom
=Depths.pp= function by hand since =ppx_deriving.show= is not powerful enough to
work for all custom types. This is one drawback of strong static type systems.

** Tracing function execution

Say you want to now debug the =resolve= function in your =Resolver= module, but
the return value of =resolve= is of type =Resolver.t=. If you didn't have the
=[@@deriving show]= =ppx= annotation on =type t= and didn't write the custom
=Scopes.pp= and =Depths.pp= functions, this would be part of the output of
tracing a call to =Resolver.resolve= in =utop= (I cut off the rest of the output
since it wasn't important):

#+BEGIN_SRC ocaml
utop[1]> #trace Resolver.resolve;;
Resolver.resolve is now traced.
utop[2]> Scanner.make_scanner "var x = 1; { var y = 2; }"
|> Scanner.scan_tokens
|> Parser.make_parser
|> Parser.parse
|> Resolver.make_resolver
|> Resolver.resolve;;
Resolver.resolve <--
  {Resolver.statements =
    [Parser.VarDeclaration
      {Parser.name =
        {Scanner.token_type = Scanner.Identifier; lexeme = "x";
         literal = Value.LoxNil; line = 1};
       init =
        Parser.Literal
         {Parser.token =
           {Scanner.token_type = Scanner.Number; lexeme = "1";
            literal = Value.LoxNumber 1.; line = 1};
          value = Value.LoxNumber 1.}};
     Parser.Block
      [Parser.VarDeclaration
        {Parser.name =
          {Scanner.token_type = Scanner.Identifier; lexeme = "y";
           literal = Value.LoxNil; line = 1};
         init =
          Parser.Literal
           {Parser.token =
             {Scanner.token_type = Scanner.Number; lexeme = "2";
              literal = Value.LoxNumber 2.; line = 1};
            value = Value.LoxNumber 2.}}]];
   scopes = <abstr>; depths = <abstr>;
#+END_SRC

Notice this last line: =scopes = <abstr>; depths = <abstr>;=. The =<abstr>=
value indicates that OCaml does not know how to print values of the =Scopes.t=
or =Depths.t= type since there are no dedicated =pp= functions for those types.

Once I added the =[@@deriving show]= annotation back to =type t=, wrote the
=Scopes.pp= and =Depths.pp= functions, and added the relevant =#install_printer=
lines to =.ocamlinit=, this was the full output of the same trace to
=Resolver.resolve=:

#+BEGIN_SRC ocaml
utop[1]> #trace Resolver.resolve;;
Resolver.resolve is now traced.
utop[2]> Scanner.make_scanner "var x = 1; { var y = 2; }"
|> Scanner.scan_tokens
|> Parser.make_parser
|> Parser.parse
|> Resolver.make_resolver
|> Resolver.resolve;;
Resolver.resolve <--
  { Resolver.Resolver.statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ];
    scopes = {}; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve <--
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "1"; literal = (Value.Value.LoxNumber 1.); line = 1 };
             value = (Value.Value.LoxNumber 1.) }))
      ];
    scopes = {}; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve -->
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "1"; literal = (Value.Value.LoxNumber 1.); line = 1 };
             value = (Value.Value.LoxNumber 1.) }))
      ];
    scopes = {}; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve <--
  { Resolver.Resolver.statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                 line = 1 };
               value = (Value.Value.LoxNumber 2.) })
          })
      ];
    scopes = {}; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve <--
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "2"; literal = (Value.Value.LoxNumber 2.); line = 1 };
             value = (Value.Value.LoxNumber 2.) }))
      ];
    scopes = { y: declared, }; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve -->
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "2"; literal = (Value.Value.LoxNumber 2.); line = 1 };
             value = (Value.Value.LoxNumber 2.) }))
      ];
    scopes = { y: declared, }; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve -->
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "2"; literal = (Value.Value.LoxNumber 2.); line = 1 };
             value = (Value.Value.LoxNumber 2.) }))
      ];
    scopes = { y: declared, }; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve <--
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "2"; literal = (Value.Value.LoxNumber 2.); line = 1 };
             value = (Value.Value.LoxNumber 2.) }))
      ];
    scopes = {}; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve -->
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "2"; literal = (Value.Value.LoxNumber 2.); line = 1 };
             value = (Value.Value.LoxNumber 2.) }))
      ];
    scopes = {}; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
Resolver.resolve -->
  { Resolver.Resolver.statements =
    [(Parser.Parser.Expression
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "2"; literal = (Value.Value.LoxNumber 2.); line = 1 };
             value = (Value.Value.LoxNumber 2.) }))
      ];
    scopes = {}; depths = {};
    parsed_statements =
    [(Parser.Parser.VarDeclaration
        { Parser.Parser.name =
          { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
            lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
          init =
          (Parser.Parser.Literal
             { Parser.Parser.token =
               { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                 lexeme = "1"; literal = (Value.Value.LoxNumber 1.);
                 line = 1 };
               value = (Value.Value.LoxNumber 1.) })
          });
      (Parser.Parser.Block
         [(Parser.Parser.VarDeclaration
             { Parser.Parser.name =
               { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
                 lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
               init =
               (Parser.Parser.Literal
                  { Parser.Parser.token =
                    { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                      lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                      line = 1 };
                    value = (Value.Value.LoxNumber 2.) })
               })
           ])
      ]
    }
- : Resolver.t =
{ Resolver.Resolver.statements =
  [(Parser.Parser.Expression
      (Parser.Parser.Literal
         { Parser.Parser.token =
           { Scanner.Scanner.token_type = Scanner.Scanner.Number;
             lexeme = "2"; literal = (Value.Value.LoxNumber 2.); line = 1 };
           value = (Value.Value.LoxNumber 2.) }))
    ];
  scopes = {}; depths = {};
  parsed_statements =
  [(Parser.Parser.VarDeclaration
      { Parser.Parser.name =
        { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
          lexeme = "x"; literal = Value.Value.LoxNil; line = 1 };
        init =
        (Parser.Parser.Literal
           { Parser.Parser.token =
             { Scanner.Scanner.token_type = Scanner.Scanner.Number;
               lexeme = "1"; literal = (Value.Value.LoxNumber 1.); line = 1 };
             value = (Value.Value.LoxNumber 1.) })
        });
    (Parser.Parser.Block
       [(Parser.Parser.VarDeclaration
           { Parser.Parser.name =
             { Scanner.Scanner.token_type = Scanner.Scanner.Identifier;
               lexeme = "y"; literal = Value.Value.LoxNil; line = 1 };
             init =
             (Parser.Parser.Literal
                { Parser.Parser.token =
                  { Scanner.Scanner.token_type = Scanner.Scanner.Number;
                    lexeme = "2"; literal = (Value.Value.LoxNumber 2.);
                    line = 1 };
                  value = (Value.Value.LoxNumber 2.) })
             })
         ])
    ]
  }
utop[8]>
#+END_SRC

Notice how =utop= now knows how to print the =Scopes.t= and =Depths.t= types,
like =scopes = { y: declared, }; depths = {};=, instead of just =scopes =
<abstr>; depths = <abstr>;=. This technique is incredibly useful for debugging
by tracing functions in the REPL and using the REPL interactively in general.

I hope this overview of interactive OCaml development with =utop= was useful.
Even though OCaml is a language that has an uncompromisingly strict static type
system, it's still possible to get some of the useful interactive features
of more dynamic languages like Lisp through a configurable plugin-based REPL and
syntax extensions that help minimize boilerplate. Sometimes you really can have
your cake and eat it too!

* Footnotes
* COMMENT Local Variables                          :ARCHIVE:
# Local Variables:
# eval: (org-hugo-auto-export-mode)
# End:
